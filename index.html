<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Room Quiz (No Backend)</title>
  <style>
    :root{--bg:#0f172a;--card:#111827;--muted:#94a3b8;--accent:#3b82f6;--ok:#22c55e;--bad:#ef4444}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1220,#0f172a);color:#e5e7eb;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,Helvetica,sans-serif}
    .container{max-width:1100px;margin:0 auto;padding:24px;display:grid;grid-template-columns:320px 1fr;gap:24px}
    .card{background:#111827;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:18px;min-height:70vh}
    h1{margin:0 0 8px 0}
    h2{margin:8px 0;color:#cbd5e1;font-size:18px}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;border:none;border-radius:12px;padding:12px 16px;background:#1f2937;color:#f8fafc;font-weight:700;cursor:pointer}
    .btn.primary{background:var(--accent)} .btn.ok{background:var(--ok)} .btn.bad{background:var(--bad)}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:10px;align-items:center}
    .stack{display:flex;flex-direction:column;gap:12px}
    textarea,input{width:100%;background:#0b1020;border:1px solid #1f2937;color:#e5e7eb;border-radius:12px;padding:10px 12px}
    textarea{min-height:160px;resize:vertical}
    .muted{color:#94a3b8}
    .list{display:flex;flex-direction:column;gap:10px;max-height:60vh;overflow:auto}
    .item{display:flex;justify-content:space-between;align-items:center;background:#0b1020;border:1px solid #1f2937;border-radius:12px;padding:12px}
    .qbox{background:#0b1020;border:1px solid #1f2937;border-radius:16px;padding:16px}
    .answers{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
    .ans{padding:14px;background:#1f2937;border:none;border-radius:12px;color:#e5e7eb;font-weight:700;cursor:pointer}
    .ans.correct{outline:2px solid var(--ok)} .ans.wrong{outline:2px solid var(--bad)}
    .center{min-height:200px;display:flex;align-items:center;justify-content:center;color:#cbd5e1}
    .hidden{display:none}
    .banner{padding:10px;border:1px solid #334155;border-radius:10px;background:#0b1020;color:#cbd5e1}
    @media (max-width:960px){.container{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="container">
    <!-- LEFT: Home / Host / Join -->
    <div class="card">
      <h1>Room Quiz</h1>
      <div class="muted" style="margin-bottom:14px">No backend. Syncs across tabs in the <b>same browser</b> using BroadcastChannel + localStorage.</div>

      <div class="row" style="gap:12px">
        <button class="btn ok" id="hostBtn">Host</button>
        <button class="btn primary" id="joinBtn">Join</button>
      </div>

      <!-- Host panel -->
      <div class="stack hidden" id="hostPanel">
        <div class="banner">Hosting a room here makes your tab the <b>host authority</b>. Keep it open so participants in other tabs can join and progress.</div>
        <h2>Provide up to 10 questions</h2>
        <textarea id="hostQuestions" placeholder="Use this plain-text format (blank line between questions):
1. Which is a vowel?
A) A
B) R
C) S
D) T
Answer: A

2. 2+2=?
A) 1
B) 2
C) 3
D) 4
Answer: D"></textarea>
        <div class="row">
          <input id="roomTitle" placeholder="Optional room title (default: Quiz Room)"/>
          <button class="btn ok" id="createFromQuestions">Create room</button>
        </div>
      </div>

      <!-- Join panel -->
      <div class="stack hidden" id="joinPanel">
        <h2>Available rooms (this browser)</h2>
        <div class="list" id="roomsList"></div>
      </div>

      <div class="muted" style="margin-top:auto">For cross-device real-time, a backend or signaling service is required. This build avoids Firestore entirely.</div>
    </div>

    <!-- RIGHT: Room view -->
    <div class="card">
      <div id="roomPane" class="stack"><div class="center">Choose <b>Host</b> or <b>Join</b> to begin.</div></div>
    </div>
  </div>

  <script>
    /* =========================
       Minimal no-backend runtime
       ========================= */
    const roomsKey = 'quiz_rooms_v1';
    const bcLobby = new BroadcastChannel('quiz_lobby');
    const roomChannels = new Map(); // roomId -> BroadcastChannel

    const hostBtn = document.getElementById('hostBtn');
    const joinBtn = document.getElementById('joinBtn');
    const hostPanel = document.getElementById('hostPanel');
    const joinPanel = document.getElementById('joinPanel');
    const hostQuestions = document.getElementById('hostQuestions');
    const createFromQuestions = document.getElementById('createFromQuestions');
    const roomsList = document.getElementById('roomsList');
    const roomPane = document.getElementById('roomPane');
    const roomTitle = document.getElementById('roomTitle');

    // This tab's participant id
    const myId = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2);

    // Navigation
    hostBtn.onclick = ()=>{ hostPanel.classList.remove('hidden'); joinPanel.classList.add('hidden'); };
    joinBtn.onclick = ()=>{ hostPanel.classList.add('hidden'); joinPanel.classList.remove('hidden'); renderRoomsList(); };

    /* ---------- Storage helpers ---------- */
    function loadRooms(){
      try { return JSON.parse(localStorage.getItem(roomsKey)||'[]'); } catch { return []; }
    }
    function saveRooms(rooms){ localStorage.setItem(roomsKey, JSON.stringify(rooms)); }
    function upsertRoom(room){
      const rooms = loadRooms();
      const i = rooms.findIndex(r=>r.id===room.id);
      if(i>=0) rooms[i]=room; else rooms.unshift(room);
      saveRooms(rooms);
      bcLobby.postMessage({type:'rooms_updated'});
    }

    /* ---------- Parser ---------- */
    function parseQuestions(text){
      const blocks = text.split(/\n\s*\n/).map(b=>b.trim()).filter(Boolean);
      const out = [];
      for(const block of blocks){
        const lines = block.split(/\n/).map(l=>l.trim()).filter(Boolean);
        const qLine = (lines[0]||'').replace(/^\d+\.?\s*/, '');
        const opts = [];
        for(const L of ['A','B','C','D']){
          const ln = lines.find(x => new RegExp(`^${L}[)\\.]\\s*`, 'i').test(x)) || '';
          opts.push(
            ln.replace(/^[A-Da-d][)\\.]\s*/, '')
              .replace(/\s*[-–]\s*\d+%$/, '')
              .replace(/\s*Explanation:.*/i, '')
              .trim()
          );
        }
        const ansLine = lines.find(l => /^answer\s*:/i.test(l)) || '';
        const letter = (ansLine.match(/[A-D]/i)||[null])[0];
        if(!qLine || opts.some(o=>!o) || !letter) continue;
        out.push({ q: qLine, options: opts, answer: {A:0,B:1,C:2,D:3}[letter.toUpperCase()] });
      }
      return out.slice(0,10);
    }

    /* ---------- Lobby (list rooms) ---------- */
    function renderRoomsList(){
      const rooms = loadRooms().filter(r=>!r.archived);
      roomsList.innerHTML = '';
      if(rooms.length===0){ const div=document.createElement('div'); div.className='muted'; div.textContent='No rooms yet.'; roomsList.appendChild(div); return; }
      rooms.forEach(r=>{
        const row = document.createElement('div'); row.className='item';
        row.innerHTML = `<div><b>${r.title||'Room'}</b><div class="muted">${r.status==='in_progress'?'In progress':r.status} · ${Object.keys(r.participants||{}).length} joined</div></div>`;
        const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Join'; btn.onclick=()=> joinRoom(r.id);
        row.appendChild(btn); roomsList.appendChild(row);
      });
    }
    bcLobby.onmessage = (ev)=>{ if(ev.data?.type==='rooms_updated') renderRoomsList(); };
    window.addEventListener('storage', (e)=>{ if(e.key===roomsKey) renderRoomsList(); });

    /* ---------- Host create ---------- */
    createFromQuestions.onclick = ()=>{
      const parsed = parseQuestions(hostQuestions.value);
      if(parsed.length===0){ alert('Could not parse questions.'); return; }
      const id = 'room_'+Math.random().toString(36).slice(2);
      const room = {
        id,
        title: (roomTitle.value.trim()||'Quiz Room'),
        createdAt: Date.now(),
        archived:false,
        status:'in_progress',
        hostId: myId,
        currentIndex:0,
        questions: parsed,
        participants: {}, // pid->{joinedAt}
        answers: {},      // pid->{choice,at}
        phase:'question',
        revealAt:null,
        hostHeartbeat: Date.now()
      };
      upsertRoom(room);
      // start acting as host authority for this room
      hostRoom(id);
      openRoom(id, true);
      hostQuestions.value=''; roomTitle.value='';
    };

    /* ---------- Room channels & authority ---------- */
    function getRoomChannel(roomId){
      if(!roomChannels.has(roomId)) roomChannels.set(roomId, new BroadcastChannel('quiz_room_'+roomId));
      return roomChannels.get(roomId);
    }

    function hostRoom(roomId){
      const ch = getRoomChannel(roomId);
      // Host listens for join/answer and updates state in localStorage then broadcasts full state
      ch.onmessage = (ev)=>{
        const msg = ev.data||{};
        let rooms = loadRooms();
        const i = rooms.findIndex(r=>r.id===roomId);
        if(i<0) return;
        const r = rooms[i];
        if(r.hostId !== myId) return; // only current host tab processes
        if(msg.type==='join'){ r.participants[msg.pid] = { joinedAt: Date.now() }; }
        if(msg.type==='answer'){
          if(r.phase!=='question' || r.currentIndex!==msg.index) return;
          r.answers[msg.pid] = { choice: msg.choice, at: Date.now() };
        }
        // Advance logic
        const total = Object.keys(r.participants||{}).length;
        const answered = Object.keys(r.answers||{}).length;
        if(r.phase==='question' && total>0 && answered>=total){ r.phase='reveal'; r.revealAt=Date.now(); }
        if(r.phase==='reveal' && r.revealAt && (Date.now()-r.revealAt)>=3000){
          const next = r.currentIndex+1;
          if(next >= (r.questions||[]).length){ r.status='finished'; r.phase='question'; r.answers={}; r.revealAt=null; }
          else { r.currentIndex=next; r.phase='question'; r.answers={}; r.revealAt=null; }
        }
        r.hostHeartbeat = Date.now();
        rooms[i]=r; saveRooms(rooms);
        ch.postMessage({type:'state', room:r});
        bcLobby.postMessage({type:'rooms_updated'});
      };

      // Host heartbeat interval & auto-advance tick
      const tick = setInterval(()=>{
        let rooms = loadRooms();
        const i = rooms.findIndex(r=>r.id===roomId);
        if(i<0){ clearInterval(tick); return; }
        const r = rooms[i];
        if(r.hostId !== myId){ clearInterval(tick); return; }
        // auto-advance in reveal phase
        if(r.phase==='reveal' && r.revealAt && (Date.now()-r.revealAt)>=3000){
          const next = r.currentIndex+1;
          if(next >= (r.questions||[]).length){ r.status='finished'; r.phase='question'; r.answers={}; r.revealAt=null; }
          else { r.currentIndex=next; r.phase='question'; r.answers={}; r.revealAt=null; }
        }
        r.hostHeartbeat = Date.now();
        rooms[i]=r; saveRooms(rooms);
        ch.postMessage({type:'state', room:r});
        bcLobby.postMessage({type:'rooms_updated'});
      }, 500);

      // Mark this tab is hosting this room
      window.addEventListener('beforeunload', ()=>{
        // optional: transfer host? For simplicity we just keep last state; other tabs won't advance.
      });
    }

    /* ---------- Join / Open room ---------- */
    function joinRoom(roomId){
      const ch = getRoomChannel(roomId);
      ch.postMessage({type:'join', pid: myId});
      openRoom(roomId, false);
    }

    function openRoom(roomId, iAmHost){
      const ch = getRoomChannel(roomId);
      ch.onmessage = (ev)=>{
        const msg = ev.data||{};
        if(msg.type==='state' && msg.room && msg.room.id===roomId){
          renderRoom(msg.room, iAmHost);
        }
      };
      // Render immediately from localStorage (may be slightly stale)
      const r = loadRooms().find(x=>x.id===roomId);
      if(r) renderRoom(r, iAmHost);
    }

    function submitAnswer(roomId, index, choice){
      const ch = getRoomChannel(roomId);
      ch.postMessage({type:'answer', pid: myId, index, choice});
    }

    /* ---------- UI: render room ---------- */
    function renderRoom(room, iAmHost){
      roomPane.innerHTML = '';
      const head = document.createElement('div'); head.className='row';
      const hbOld = (Date.now() - (room.hostHeartbeat||0)) > 3000;
      head.innerHTML = `<div class="muted">${room.title||'Room'} · ${Object.keys(room.participants||{}).length} players ${hbOld? '· <span style="color:#fbbf24">Host inactive?</span>':''}</div>`;
      const leave = document.createElement('button'); leave.className='btn bad'; leave.textContent='Leave'; leave.onclick = ()=>{ roomPane.innerHTML='<div class="center">Left room.</div>'; };
      head.appendChild(leave); roomPane.appendChild(head);

      if(room.status==='finished'){
        const box = document.createElement('div'); box.className='center'; box.textContent = iAmHost ? 'Out of questions. Add more to continue.' : 'Waiting for host to add more questions…';
        roomPane.appendChild(box); return;
      }

      const idx = room.currentIndex; const q = (room.questions||[])[idx];
      if(!q){ const box = document.createElement('div'); box.className='center'; box.textContent='Waiting for first question…'; roomPane.appendChild(box); return; }

      const inReveal = room.phase==='reveal';

      const box = document.createElement('div'); box.className='qbox';
      const small = document.createElement('div'); small.className='muted'; small.textContent = `Question ${idx+1} of ${room.questions.length}`;
      const text = document.createElement('div'); text.style.cssText='font-size:20px;margin:6px 0 10px 0;font-weight:700'; text.textContent = q.q;
      const answers = document.createElement('div'); answers.className='answers';

      [0,1,2,3].forEach(i=>{
        const b = document.createElement('button'); b.className='ans'; b.textContent = `${['A','B','C','D'][i]}. ${q.options[i]}`;
        b.disabled = inReveal; // can answer only during question phase
        b.onclick = ()=> submitAnswer(room.id, idx, i);
        if(inReveal){ if(i===q.answer) b.classList.add('correct'); }
        answers.appendChild(b);
      });

      const counts = document.createElement('div'); counts.className='muted';
      counts.textContent = `Answered: ${Object.keys(room.answers||{}).length}/${Object.keys(room.participants||{}).length}`;

      box.appendChild(small); box.appendChild(text); box.appendChild(answers); box.appendChild(counts);
      if(inReveal){
        const note = document.createElement('div'); note.className='muted'; note.style.marginTop='8px'; note.textContent='Showing correct answer…'; box.appendChild(note);
      }

      // Host controls (add more / restart)
      if(iAmHost){
        const hostBox = document.createElement('div'); hostBox.className='stack'; hostBox.style.marginTop='10px';
        const ta = document.createElement('textarea'); ta.placeholder='Paste 10 more questions in the same format.';
        const addBtn = document.createElement('button'); addBtn.className='btn ok'; addBtn.textContent='Add up to 10';
        addBtn.onclick = ()=>{
          const extra = parseQuestions(ta.value); if(extra.length===0){ alert('Nothing parsed'); return; }
          const rooms = loadRooms(); const i = rooms.findIndex(r=>r.id===room.id); if(i<0) return;
          const r = rooms[i]; if(r.hostId!==myId){ alert('Only host tab can add questions.'); return; }
          r.questions = (r.questions||[]).concat(extra); r.status='in_progress'; saveRooms(rooms); getRoomChannel(room.id).postMessage({type:'state', room:r}); bcLobby.postMessage({type:'rooms_updated'}); ta.value='';
        };
        const restart = document.createElement('button'); restart.className='btn primary'; restart.textContent='Restart from Q1';
        restart.onclick = ()=>{
          const rooms = loadRooms(); const i = rooms.findIndex(r=>r.id===room.id); if(i<0) return;
          const r = rooms[i]; if(r.hostId!==myId){ alert('Only host tab can restart.'); return; }
          r.status='in_progress'; r.currentIndex=0; r.answers={}; r.phase='question'; r.revealAt=null; saveRooms(rooms); getRoomChannel(room.id).postMessage({type:'state', room:r});
        };
        hostBox.appendChild(ta); hostBox.appendChild(addBtn); hostBox.appendChild(restart); roomPane.appendChild(hostBox);
      }

      roomPane.appendChild(box);
    }

    /* =========================
       Tiny self-tests (dev console)
       ========================= */
    ;(function tests(){
      const sample = `1. Q?\nA) a\nB) b\nC) c\nD) d\nAnswer: C`;
      const parsed = parseQuestions(sample);
      console.assert(parsed.length===1 && parsed[0].answer===2 && parsed[0].options[2]==='c', 'parseQuestions basic test failed');
    })();

  </script>
</body>
</html>
