<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kahoot-Style Quiz (Realm Web)</title>
  <style>
    :root{--bg:#0f172a;--card:#111827;--muted:#94a3b8;--accent:#3b82f6;--ok:#22c55e;--bad:#ef4444}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1220,#0f172a);color:#e5e7eb;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,Helvetica,sans-serif}
    .container{max-width:1100px;margin:0 auto;padding:24px;display:grid;grid-template-columns:320px 1fr;gap:24px}
    .card{background:#111827;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:18px;min-height:70vh}
    h1{margin:0 0 8px 0}
    h2{margin:8px 0;color:#cbd5e1;font-size:18px}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;border:none;border-radius:12px;padding:12px 16px;background:#1f2937;color:#f8fafc;font-weight:700;cursor:pointer}
    .btn.primary{background:var(--accent)} .btn.ok{background:var(--ok)} .btn.bad{background:var(--bad)}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:10px;align-items:center}
    .stack{display:flex;flex-direction:column;gap:12px}
    textarea,input{width:100%;background:#0b1020;border:1px solid #1f2937;color:#e5e7eb;border-radius:12px;padding:10px 12px}
    textarea{min-height:160px;resize:vertical}
    .muted{color:#94a3b8}
    .list{display:flex;flex-direction:column;gap:10px;max-height:60vh;overflow:auto}
    .item{display:flex;justify-content:space-between;align-items:center;background:#0b1020;border:1px solid #1f2937;border-radius:12px;padding:12px}
    .qbox{background:#0b1020;border:1px solid #1f2937;border-radius:16px;padding:16px}
    .answers{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
    .ans{padding:14px;background:#1f2937;border:none;border-radius:12px;color:#e5e7eb;font-weight:700;cursor:pointer}
    .ans.correct{outline:2px solid var(--ok)} .ans.wrong{outline:2px solid var(--bad)}
    .center{min-height:200px;display:flex;align-items:center;justify-content:center;color:#cbd5e1}
    .hidden{display:none}
    .count{font-size:48px;font-weight:900;text-align:center}
    @media (max-width:960px){.container{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="container">
    <!-- LEFT: Host / Join -->
    <div class="card">
      <h1>Kahoot-Style Quiz</h1>
      <div class="muted" style="margin-bottom:14px">MongoDB Atlas App Services (Realm Web). No visible user IDs or room codes. Rooms appear in the list when published.</div>

      <div class="row" style="gap:12px">
        <button class="btn ok" id="hostBtn">Host</button>
        <button class="btn primary" id="joinBtn">Join</button>
      </div>

      <!-- Host setup -->
      <div class="stack hidden" id="hostPanel">
        <h2>Create Room</h2>
        <input id="roomTitle" placeholder="Room title (default: Quiz Room)"/>
        <input id="maxPlayers" type="number" min="1" max="200" placeholder="Participant count (includes host)"/>
        <textarea id="hostQuestions" placeholder="Paste questions (blank line between):
1. Question text?
A) Option A
B) Option B
C) Option C
D) Option D
Answer: B
Explanation: why B is correct

2. Next question...
A) ...
B) ...
C) ...
D) ...
Answer: D
Explanation: ..."></textarea>
        <div class="row">
          <button class="btn ok" id="createRoom">Create & Publish</button>
        </div>
      </div>

      <!-- Join list -->
      <div class="stack hidden" id="joinPanel">
        <h2>Available Rooms</h2>
        <div class="list" id="roomsList"></div>
      </div>

      <div class="muted" style="margin-top:auto">Reminder: For production, configure Realm rules so only the host client can modify room control fields.</div>
    </div>

    <!-- RIGHT: Room view -->
    <div class="card">
      <div id="roomPane" class="stack"><div class="center">Choose <b>Host</b> or <b>Join</b> to begin.</div></div>
    </div>
  </div>

  <!-- Realm Web SDK -->
  <script src="https://unpkg.com/realm-web/dist/bundle.iife.js"></script>
  <script>
    // ====== CONFIG ======
    const REALM_APP_ID = "your-realm-app-id"; // <-- replace in Atlas App Services
    const DB_NAME = "quiz";

    // ====== Client identity (ephemeral, not shown) ======
    const clientId = (localStorage.getItem('quiz_client_id')) || (()=>{
      const id = (self.crypto?.randomUUID?.() || Math.random().toString(36).slice(2));
      localStorage.setItem('quiz_client_id', id); return id;
    })();

    // ====== UI Refs ======
    const hostBtn = document.getElementById('hostBtn');
    const joinBtn = document.getElementById('joinBtn');
    const hostPanel = document.getElementById('hostPanel');
    const joinPanel = document.getElementById('joinPanel');
    const roomsList = document.getElementById('roomsList');
    const roomPane = document.getElementById('roomPane');
    const roomTitle = document.getElementById('roomTitle');
    const maxPlayers = document.getElementById('maxPlayers');
    const hostQuestions = document.getElementById('hostQuestions');
    const createRoomBtn = document.getElementById('createRoom');

    hostBtn.onclick = ()=>{ hostPanel.classList.remove('hidden'); joinPanel.classList.add('hidden'); };
    joinBtn.onclick = ()=>{ hostPanel.classList.add('hidden'); joinPanel.classList.remove('hidden'); refreshRooms(); };

    // ====== Realm boot ======
    const app = new Realm.App({ id: REALM_APP_ID });
    let user = null, mongo = null, db = null, Rooms=null, Questions=null, Answers=null;

    async function ensureUser(){
      if(!user) user = await app.logIn(Realm.Credentials.anonymous());
      if(!mongo){ mongo = app.currentUser.mongoClient("mongodb-atlas"); db = mongo.db(DB_NAME); Rooms = db.collection('rooms'); Questions = db.collection('questions'); Answers = db.collection('answers'); }
      return user;
    }

    // ====== Host: create & publish room ======
    createRoomBtn.onclick = async ()=>{
      await ensureUser();
      const title = (roomTitle.value.trim()||'Quiz Room');
      const max = Math.max(1, parseInt(maxPlayers.value||'0',10));
      const parsed = parseQuestions(hostQuestions.value);
      if(!max){ alert('Enter participant count'); return; }
      if(parsed.length===0){ alert('Paste questions first'); return; }

      // 1) create room (status: lobby/public)
      const r = await Rooms.insertOne({
        title, maxParticipants:max, participants: {[clientId]: {joinedAt:new Date(), ready:false}},
        createdAt: new Date(), status:'lobby', phase:'setup', // setup->lobby->countdown->question->reveal->wait_next
        hostId: clientId,
        currentIndex: 0,
        answers: {}, // {clientId:{choice,at}}
        nextAcks: {}, // {clientId:true}
        revealAt: null
      });
      const roomId = r.insertedId; // internal only

      // 2) insert questions
      const docs = parsed.map((q,i)=>({ roomId, index:i, ...q }));
      await Questions.insertMany(docs);

      // 3) publish: phase->lobby so others can see
      await Rooms.updateOne({ _id: roomId }, { $set: { phase:'lobby', status:'lobby' } });

      // open room as host
      openRoom(roomId, true);
      roomTitle.value=''; maxPlayers.value=''; hostQuestions.value='';
    };

    // ====== Join list ======
    async function refreshRooms(){
      await ensureUser();
      const rooms = await Rooms.find({ status: { $in:['lobby','in_progress'] } }, { sort: { createdAt: -1 }, limit: 50 });
      roomsList.innerHTML='';
      if(rooms.length===0){ const div=document.createElement('div'); div.className='muted'; div.textContent='No public rooms yet.'; roomsList.appendChild(div); return; }
      rooms.forEach(r=>{
        const row = document.createElement('div'); row.className='item';
        const joined = r.participants ? Object.keys(r.participants).length : 0;
        row.innerHTML = `<div><b>${r.title||'Room'}</b><div class="muted">${r.status} Â· ${joined}/${r.maxParticipants} joined</div></div>`;
        const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Join'; btn.onclick = ()=> joinRoom(r._id);
        row.appendChild(btn); roomsList.appendChild(row);
      });
    }

    async function joinRoom(roomId){
      await ensureUser();
      // add participant (idempotent)
      await Rooms.updateOne({ _id: roomId }, { $set: { ["participants."+clientId]: { joinedAt:new Date(), ready:false } }, $setOnInsert:{} });
      openRoom(roomId, false);
    }

    // ====== Change stream watcher per room ======
    async function watchRoom(roomId){
      await ensureUser();
      const pipeline = [{ $match: { "fullDocument._id": roomId } }];
      for await (const change of Rooms.watch(pipeline)){
        const room = change.fullDocument;
        renderRoom(roomId, room);
      }
    }

    // ====== Room lifecycle helpers ======
    async function startCountdown(roomId){
      await Rooms.updateOne({ _id: roomId, phase:'lobby' }, { $set: { phase:'countdown', countdownEndsAt: new Date(Date.now()+3000), status:'in_progress' } });
    }

    async function openQuestion(roomId){
      await Rooms.updateOne({ _id: roomId, phase:'countdown' }, { $set: { phase:'question', answers:{}, nextAcks:{} } });
    }

    async function submitAnswer(roomId, index, choice){
      await Rooms.updateOne({ _id: roomId, phase:'question' }, { $set: { ["answers."+clientId]: { choice, at:new Date(), index } } });
    }

    async function revealIfAllAnswered(room){
      const total = Object.keys(room.participants||{}).length;
      const answered = Object.keys(room.answers||{}).length;
      if(room.phase==='question' && total>0 && answered>=total){
        await Rooms.updateOne({ _id: room._id, phase:'question' }, { $set: { phase:'reveal', revealAt: new Date() } });
      }
    }

    async function ackNext(roomId){
      await Rooms.updateOne({ _id: roomId, phase:'reveal' }, { $set: { ["nextAcks."+clientId]: true } });
    }

    async function advanceIfAllAck(room){
      const total = Object.keys(room.participants||{}).length;
      const acked = Object.keys(room.nextAcks||{}).length;
      if(room.phase==='reveal' && total>0 && acked>=total){
        const totalQs = await Questions.count({ roomId: room._id });
        const next = room.currentIndex + 1;
        if(next >= totalQs){
          await Rooms.updateOne({ _id: room._id, phase:'reveal' }, { $set: { status:'finished', phase:'wait_more', answers:{}, nextAcks:{}, revealAt:null } });
        } else {
          await Rooms.updateOne({ _id: room._id, phase:'reveal' }, { $set: { currentIndex: next, phase:'question', answers:{}, nextAcks:{}, revealAt:null } });
        }
      }
    }

    async function hostAddMore(roomId, text){
      const extra = parseQuestions(text);
      if(extra.length===0){ alert('Nothing parsed'); return; }
      await Questions.insertMany(extra.map((q,i)=>({ roomId, index: Date.now()+i, ...q })));
      await Rooms.updateOne({ _id: roomId }, { $set: { status:'in_progress', phase:'question', answers:{}, nextAcks:{}, revealAt:null } });
    }

    // ====== Open & render room ======
    let watching = false;
    async function openRoom(roomId, iAmHost){
      roomPane.innerHTML = '<div class="center">Loading roomâ¦</div>';
      await ensureUser();
      // Initial fetch
      const room = await Rooms.findOne({ _id: roomId });
      renderRoom(roomId, room, iAmHost);
      if(!watching){ watching=true; watchRoom(roomId); }
    }

    async function renderRoom(roomId, room, iAmHost){
      if(!room) { roomPane.innerHTML = '<div class="center">Room missing</div>'; return; }
      roomPane.innerHTML = '';

      const joined = room.participants ? Object.keys(room.participants).length : 0;
      const header = document.createElement('div'); header.className='row';
      header.innerHTML = `<div class="muted">${room.title||'Room'} Â· ${joined}/${room.maxParticipants} players</div>`;
      const leave = document.createElement('button'); leave.className='btn bad'; leave.textContent='Leave'; leave.onclick=()=>{ roomPane.innerHTML='<div class="center">Left room.</div>'; };
      header.appendChild(leave); roomPane.appendChild(header);

      // Auto-transitions
      if(room.phase==='lobby'){
        // rule 7: start when all joined (including host)
        if(joined >= room.maxParticipants && iAmHost){ await startCountdown(roomId); }
        const box = document.createElement('div'); box.className='center'; box.textContent = `Waiting for players ${joined}/${room.maxParticipants}â¦`;
        roomPane.appendChild(box); return;
      }
      if(room.phase==='countdown'){
        const t = (new Date(room.countdownEndsAt||Date.now())).getTime();
        const wrap = document.createElement('div'); wrap.className='center';
        const span = document.createElement('div'); span.className='count'; wrap.appendChild(span); roomPane.appendChild(wrap);
        const timer = setInterval(()=>{
          const left = Math.ceil((t - Date.now())/1000);
          span.textContent = left>0 ? left : 'Go!';
          if(left<=0){ clearInterval(timer); if(iAmHost) openQuestion(roomId); }
        }, 200);
        return;
      }

      // Fetch current question
      const q = await Questions.findOne({ roomId: room._id, index: room.currentIndex });
      if(!q){ const box=document.createElement('div'); box.className='center'; box.textContent='Waiting for first questionâ¦'; roomPane.appendChild(box); return; }

      const inReveal = room.phase==='reveal';
      const myAns = room.answers?.[clientId]?.choice ?? null;

      const qbox = document.createElement('div'); qbox.className='qbox';
      qbox.appendChild(el('div',{class:'muted',text:`Question ${room.currentIndex+1}` }));
      qbox.appendChild(el('div',{style:'font-size:20px;margin:6px 0 10px 0;font-weight:700',text:q.q }));

      const answers = document.createElement('div'); answers.className='answers';
      q.options.forEach((opt,i)=>{
        const b = document.createElement('button'); b.className='ans'; b.textContent = `${['A','B','C','D'][i]}. ${opt}`;
        b.disabled = inReveal || myAns!==null;
        b.onclick = ()=> submitAnswer(roomId, room.currentIndex, i);
        if(inReveal){ if(i===q.answer) b.classList.add('correct'); if(i===myAns && myAns!==q.answer) b.classList.add('wrong'); }
        answers.appendChild(b);
      });
      qbox.appendChild(answers);

      // counts + reveal explanation
      const counts = document.createElement('div'); counts.className='muted';
      const answered = Object.keys(room.answers||{}).length;
      counts.textContent = `Answered: ${answered}/${joined}`;
      qbox.appendChild(counts);

      if(inReveal){
        qbox.appendChild(el('div',{style:'height:8px'}));
        qbox.appendChild(el('div',{class:'muted',text:`Correct: ${['A','B','C','D'][q.answer]}. ${q.options[q.answer]}` }));
        if(q.explanation){ qbox.appendChild(el('div',{style:'margin-top:6px',text:`Explanation: ${q.explanation}`})); }
        const nextBtn = document.createElement('button'); nextBtn.className='btn primary'; nextBtn.style.marginTop='10px'; nextBtn.textContent='Next';
        nextBtn.onclick = ()=> ackNext(roomId);
        qbox.appendChild(nextBtn);
        // try advance
        await advanceIfAllAck(room);
      } else {
        // try reveal when all answered
        await revealIfAllAnswered(room);
      }

      // Host add-more UI when finished
      if(room.status==='wait_more' && iAmHost){
        const hostBox = document.createElement('div'); hostBox.className='stack'; hostBox.style.marginTop='10px';
        const ta = document.createElement('textarea'); ta.placeholder='Provide more questions (same format)â¦';
        const addBtn = document.createElement('button'); addBtn.className='btn ok'; addBtn.textContent='Add & Continue';
        addBtn.onclick = ()=> hostAddMore(roomId, ta.value);
        hostBox.appendChild(ta); hostBox.appendChild(addBtn);
        roomPane.appendChild(hostBox);
      }

      roomPane.appendChild(qbox);
    }

    function el(tag, attrs={}, children=[]) { const e = document.createElement(tag); Object.entries(attrs).forEach(([k,v])=>{ if(k==='class') e.className=v; else if(k==='text') e.textContent=v; else e.setAttribute(k,v); }); (children||[]).forEach(c=> e.appendChild(c)); return e; }

    // ====== Parser (with Explanation) ======
    function parseQuestions(text){
      const blocks = text.split(/\n\s*\n/).map(b=>b.trim()).filter(Boolean);
      const out = [];
      for(const block of blocks){
        const lines = block.split(/\n/).map(l=>l.trim()).filter(Boolean);
        if(lines.length<6) continue;
        const q = lines[0].replace(/^\d+\.?\s*/, '');
        const opts = [];
        for(const L of ['A','B','C','D']){
          const ln = lines.find(x => new RegExp(`^${L}[)\\.]\\s*`, 'i').test(x)) || '';
          opts.push( ln.replace(/^[A-Da-d][)\\.]\s*/, '').trim() );
        }
        const ansLine = lines.find(l=>/^answer\s*:/i.test(l))||'';
        const letter = (ansLine.match(/[A-D]/i)||[null])[0];
        const explanation = (lines.find(l=>/^explanation\s*:/i.test(l))||'').replace(/^explanation\s*:\s*/i,'');
        if(!letter) continue;
        out.push({ q, options:opts, answer:{A:0,B:1,C:2,D:3}[letter.toUpperCase()], explanation });
      }
      return out;
    }

    // Initial auth to allow join list
    ensureUser().then(refreshRooms).catch(console.error);
  </script>
</body>
</html>
